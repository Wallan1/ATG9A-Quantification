---
title: "10-Load-Data"
output: html_notebook
---

CSV import - *Mac*
*change input file path*
```{r}
testdata=read.csv(file="~/Desktop/29Jun21_analysis/NSW3017_basal_counts_29Jun21.csv",header=TRUE)
testdata$BvsS<-"Basal"
testdata$BafA<-"BafAN"
testdata$Rep<-4
nobs=nrow(testdata)
for (i in 1:nobs) {
  if (testdata[i,1]=="") {
    testdata[i,1]<-fname

  } 
  else {
    fname=testdata[i,1]

  }
}

```


CSV import - *Windows*
*MUST HAVE FILES IN R PROJECT WD* 
*change input file path*
```{r}
temp=read.csv(file="./datasets/NSW4020_11Feb22.csv",header=TRUE)
temp$BvsS<-"Basal"
temp$Rep<-1
nobs=nrow(temp)
for (i in 1:nobs) {
  if (temp[i,1]=="") {
    temp[i,1]<-fname

  } 
  else {
    fname=temp[i,1]

  }
}

```

Adding type designation
*if necessary update substring values based on filename in input document*
*check capitalization of values*
```{r}
temp$Type<-NA
ntemp<-nrow(temp)


for (c in 1:ntemp) {
  if (substr(temp[c,1],30,30)=="W") {
    temp$Type[c]<-"WT"
  }
  else if (substr(temp[c,1],30,30)=="C") {
    temp$Type[c]<-"Control"
  }
  else if (substr(temp[c,1],30,30)=="T") {
    temp$Type[c]<-"tepsin"
  }
  else {
    temp$Type[c]<-"AP4E1"
  }
  
}
temp$Type<-factor(temp$Type, levels=c("WT", "Control", "tepsin", "AP4E1"))
```

#Logic checks to ensure data is used only from properly segmented cells
*DEVELOP*
Find files where number of Nuclei in segmented cells does not match number of segmented cells:

These files should be evaluated to identify images where cells were not segmented properly. 

```{r}
ntemp<-nrow(temp)
temp[,2]<-as.numeric(temp[,2])
temp[,3]<-as.numeric(temp[,3])
rs<-c()

for (i in 1:ntemp) {
  if (!is.na(temp[i,2]) & temp[i,2]!=temp[i,3]) {
      rs<-c(rs,i)
    }
  
}

badcell1<-data.frame(temp[rs,])
```

Checking for images where the number of cells with MOC measurements does not match the number of counted cells to validated cell segmentation. All cells should have MOC measurements while not all will have puncta measurements
```{r}
ntemp<-nrow(temp)
temp[,2]<-as.numeric(temp[,2])
temp[,4]<-as.numeric(temp[,4])
ncell<-temp[1,2]
rs<-c()

for (i in 1:ntemp) {
  if (!is.na(temp[i,2]) & i!=1) {
    if (!is.na(temp[i-1,4]) & ncell!=temp[i-1,4]) {
      rs<-c(rs,i-1)
    }
    ncell<-temp[i,2]
  }
  
  if (i==ntemp){
    if (!is.na(temp[i,4]) & ncell!=temp[i,4]) {
      rs<-c(rs,i)
    }
  }
}

badcell2<-data.frame(temp[rs,])
```



*DO NOT USE*
To fill Golgi ATG9Aint with 0 values for quantification:
This function will replace NA rows in the SumGolATG9A column with 0 so they will be acknowledged in the data analysis
```{r}
temp[is.na(temp[,4]),4]<-0
```




#Data calculation operations

Calculate the ratio of Golgi localized ATG9A relative to whole cell measurement
```{r}
temp$PercGolATG9<-NA
ntemp<-nrow(temp)

for (i in 1:ntemp) {
  temp[i,28]<-(temp[i,5]/temp[i,6])*100
}
```

#Peripheral localization index calculations
Calculate half the major axis to approximate distance from the center to the periphery
```{r}
temp$MajorRadius<-NA
ntemp<-nrow(temp)

for (i in 1:ntemp) {
  temp[i,25]<-(temp[i,13]/2)
}
```


Calculate peripheral localization index (PLI)
```{r}
temp$PLI<-NA
ntemp<-nrow(temp)

cid<-1
fname<-temp[1,1]
mr<-temp[]
for (i in 1:ntemp) {
  temp[i,26]<-(temp[i,13]/temp$MajorRadius[which])
}
```





Get Sum of cell counts per type
```{r}
temp$CellSum<-NA
ntemp<-nrow(temp)

for (t in c("WT", "Control", "tepsin", "AP4E1")) {
  for (bs in c("Basal", "Starved")) {
    for (r in c("1", "2","3")) {
      
       temp$CellSum[which(temp$Type==t & temp$BvsS==bs & temp$Rep==r)]<-sum(temp$SegCellCount[which(temp$Type==t & temp$BvsS==bs & temp$Rep==r)],na.rm = TRUE)
   
    }
  }
  }
```
